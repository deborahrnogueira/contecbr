import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
import io
from datetime import datetime
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
import base64
from io import BytesIO
import matplotlib.pyplot as plt

# Configura√ß√£o da p√°gina
st.set_page_config(page_title="An√°lise Curva ABC", layout="wide")

# Constantes
LINHAS_PARA_DESCARTAR = [14, 15, 30, 59, 262]
TOOLTIPS = {
    'INCID√äNCIA DO ITEM (%)': 'Percentual que o item representa no valor total',
    'INCID√äNCIA DO ITEM (%) ACUMULADO': 'Soma acumulada dos percentuais',
    'CLASSIFICA√á√ÉO': 'A: Items cr√≠ticos (80% do valor)\nB: Items intermedi√°rios (15% do valor)\nC: Items menos cr√≠ticos (5% do valor)'
}

def carregar_dados(uploaded_file):
    """Carrega e prepara os dados da planilha"""
    try:
        file_extension = uploaded_file.name.split('.')[-1].lower()
        
        if file_extension == 'csv':
            df = pd.read_csv(uploaded_file)
        elif file_extension in ['xlsx', 'xlsm']:
            df = pd.read_excel(
                uploaded_file,
                sheet_name='ARP',
                usecols='A:Q',
                skiprows=11,
                nrows=306
            )
            
            # Converter √≠ndices das linhas para descartar para posi√ß√µes reais no DataFrame
            linhas_para_remover = [i-12 for i in LINHAS_PARA_DESCARTAR]
            df = df.drop(linhas_para_remover)
            
        else:
            raise Exception("Formato de arquivo n√£o suportado. Use .xlsx, .xlsm ou .csv")
        
        df.columns = [
            'ITEM', 'SIGLA', 'DESCRI√á√ÉO', 'UND', 'QTD', 'MO', 'MAT', 'EQUIP', 
            'SUBTOTAL', 'BDI MO', 'BDI MAT', 'BDI EQUIP', 'EQUIP S/ BDI',
            'MO C/ BDI', 'MAT C/ BDI', 'EQUIP C/ BDI2', 'TOTAL'
        ]
        
        return df
    except Exception as e:
        raise Exception(f"Erro ao carregar arquivo: {str(e)}")

def gerar_pdf(df_processado, fig_pareto, fig_pizza, resumo):
    """Gera relat√≥rio PDF com an√°lises"""
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []
    
    # T√≠tulo
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30
    )
    story.append(Paragraph("Relat√≥rio de An√°lise Curva ABC", title_style))
    
    # Sum√°rio Executivo
    story.append(Paragraph("Sum√°rio Executivo", styles['Heading2']))
    total_itens = len(df_processado)
    total_valor = df_processado['TOTAL'].sum()
    
    sumario = f"""
    Esta an√°lise contempla {total_itens} itens, totalizando {formatar_moeda_real(total_valor)}.
    Os itens foram classificados em tr√™s categorias (A, B e C) de acordo com sua representatividade financeira.
    """
    story.append(Paragraph(sumario, styles['Normal']))
    story.append(Spacer(1, 12))
    
    # Salvar gr√°ficos como imagens
    # Pareto
    pareto_img = BytesIO()
    fig_pareto.write_image(pareto_img, format='png', width=800, height=400)
    story.append(Paragraph("An√°lise de Pareto", styles['Heading2']))
    story.append(Image(pareto_img, width=400, height=200))
    
    # Pizza
    pizza_img = BytesIO()
    fig_pizza.write_image(pizza_img, format='png', width=800, height=400)
    story.append(Paragraph("Distribui√ß√£o por Classe", styles['Heading2']))
    story.append(Image(pizza_img, width=400, height=200))
    
    # Resumo em tabela
    story.append(Paragraph("Resumo por Classe", styles['Heading2']))
    resumo_data = [['Classe', 'Qtd Itens', 'Valor Total', 'Valor M√©dio']]
    for idx, row in resumo.iterrows():
        resumo_data.append([
            idx,
            f"{row['Quantidade de Itens']}",
            formatar_moeda_real(row['Valor Total']),
            formatar_moeda_real(row['Valor M√©dio'])
        ])
    
    t = Table(resumo_data)
    t.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 14),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    story.append(t)
    
    # Recomenda√ß√µes
    story.append(Paragraph("Recomenda√ß√µes", styles['Heading2']))
    recomendacoes = f"""
    1. Foco em itens classe A: Priorizar a gest√£o dos {len(df_processado[df_processado['CLASSIFICA√á√ÉO']=='A'])} itens que representam 80% do valor total.
    2. Revis√£o peri√≥dica: Estabelecer ciclos de revis√£o trimestral para itens classe A.
    3. Otimiza√ß√£o de estoques: Adequar pol√≠ticas de estoque de acordo com a classifica√ß√£o.
    """
    story.append(Paragraph(recomendacoes, styles['Normal']))
    
    doc.build(story)
    buffer.seek(0)
    return buffer

def criar_guia_uso():
    """Cria o guia de uso da ferramenta"""
    guia = """
    # Guia de Uso da Ferramenta de An√°lise Curva ABC
    
    ## 1. Carregamento de Dados
    - Use arquivos .xlsx, .xlsm ou .csv
    - Os dados devem estar na aba 'ARP'
    - O cabe√ßalho deve estar na linha 12
    
    ## 2. Interpreta√ß√£o dos Resultados
    
    ### Classifica√ß√£o ABC
    - Classe A: Itens que representam 80% do valor total
    - Classe B: Itens que representam 15% do valor total
    - Classe C: Itens que representam 5% do valor total
    
    ### Gr√°ficos
    - Pareto: Mostra a distribui√ß√£o dos itens e o acumulado
    - Pizza: Apresenta a propor√ß√£o de cada classe
    
    ## 3. Filtros e An√°lises
    - Use os filtros para focar em classes espec√≠ficas
    - Utilize a busca para encontrar itens espec√≠ficos
    - Export os dados processados em Excel
    
    ## 4. Recomenda√ß√µes de Uso
    - Atualize os dados periodicamente
    - Foque nos itens classe A para maior impacto
    - Use os filtros para an√°lises espec√≠ficas
    """
    return guia

def main():
    st.title('An√°lise Curva ABC')
    
    # Sidebar
    st.sidebar.title('Configura√ß√µes')
    st.sidebar.info('Formatos aceitos: .xlsx, .xlsm e .csv')
    
    # Adicionar bot√£o para mostrar guia
    if st.sidebar.button('üìö Mostrar Guia de Uso'):
        st.sidebar.markdown(criar_guia_uso())
    
    uploaded_file = st.sidebar.file_uploader("Carregue a planilha", type=['xlsx', 'xlsm', 'csv'])
    
    if uploaded_file is not None:
        try:
            df = carregar_dados(uploaded_file)
            df_processado = processar_dados(df)
            
            tab1, tab2, tab3, tab4 = st.tabs(['Vis√£o Geral', 'An√°lise Detalhada', 'Filtros', 'Relat√≥rio'])
            
            # Aba 1: Vis√£o Geral
            with tab1:
                # Criar gr√°ficos com tooltips melhorados
                fig_pareto = go.Figure()
                
                fig_pareto.add_trace(go.Bar(
                    x=df_processado['N√öMERO DO ITEM'],
                    y=df_processado['INCID√äNCIA DO ITEM (%)'],
                    name='Incid√™ncia',
                    marker_color=df_processado['CLASSIFICA√á√ÉO'].map({'A': 'blue', 'B': 'orange', 'C': 'green'}),
                    text=df_processado['ITEM'],
                    customdata=np.column_stack((
                        df_processado['TOTAL_FORMATADO'],
                        df_processado['CLASSIFICA√á√ÉO'],
                        df_processado['DESCRI√á√ÉO']
                    )),
                    hovertemplate="""
                    <b>Item:</b> %{text}<br>
                    <b>Descri√ß√£o:</b> %{customdata[2]}<br>
                    <b>Valor:</b> %{customdata[0]}<br>
                    <b>Classe:</b> %{customdata[1]}<br>
                    <b>Incid√™ncia:</b> %{y:.2f}%
                    <extra></extra>
                    """
                ))
                
                fig_pareto.add_trace(go.Scatter(
                    x=df_processado['N√öMERO DO ITEM'],
                    y=df_processado['INCID√äNCIA DO ITEM (%) ACUMULADO'],
                    name='Acumulado',
                    line=dict(color='red', width=2),
                    yaxis='y2',
                    hovertemplate="<b>Acumulado:</b> %{y:.2f}%<extra></extra>"
                ))
                
                fig_pareto.update_layout(
                    title='Curva ABC (Pareto)',
                    xaxis_title='N√∫mero do Item',
                    yaxis_title='Incid√™ncia Individual (%)',
                    yaxis2=dict(
                        title='Incid√™ncia Acumulada (%)',
                        overlaying='y',
                        side='right'
                    ),
                    showlegend=True,
                    height=600,
                    hovermode='x unified'
                )
                
                df_pizza = df_processado.groupby('CLASSIFICA√á√ÉO').agg({
                    'TOTAL': 'sum',
                    'ITEM': 'count'
                }).reset_index()
                
                df_pizza['Percentual'] = (df_pizza['TOTAL'] / df_pizza['TOTAL'].sum() * 100).round(2)
                
                fig_pizza = px.pie(
                    df_pizza,
                    values='TOTAL',
                    names='CLASSIFICA√á√ÉO',
                    title='Distribui√ß√£o por Classe',
                    hover_data=['Percentual'],
                    custom_data=['ITEM']
                )
                
                fig_pizza.update_traces(
                    hovertemplate="<b>Classe:</b> %{label}<br>" +
                    "<b>Valor Total:</b> R$ %{value:,.2f}<br>" +
                    "<b>Percentual:</b> %{customdata[0]:.1f}%<br>" +
                    "<b>Quantidade de Itens:</b> %{customdata[1]}<extra></extra>"
                )
                
                col1, col2 = st.columns([2, 1])
                with col1:
                    st.plotly_chart(fig_pareto, use_container_width=True)
                    # Bot√£o para download do gr√°fico Pareto
                    if st.button('üì• Download Gr√°fico Pareto'):
                        buffer = BytesIO()
                        fig_pareto.write_image(buffer, format='png')
                        st.download_button(
                            label="üíæ Salvar Gr√°fico Pareto",
                            data=buffer.getvalue(),
                            file_name="pareto.png",
                            mime="image/png"
                        )
                
                with col2:
                    st.plotly_chart(fig_pizza, use_container_width=True)
                    # Bot√£o para download do gr√°fico Pizza
                    if st.button('üì• Download Gr√°fico Pizza'):
                        buffer = BytesIO()
                        fig_pizza.write_image(buffer, format='png')
                        st.download_button(
                            label="üíæ Salvar Gr√°fico Pizza",
                            data=buffer.getvalue(),
                            file_name="pizza.png",
                            mime="image/png"
                        )
                
                st.subheader('Resumo por Classe')
                resumo = df_processado.groupby('CLASSIFICA√á√ÉO').agg({
                    'ITEM': 'count',
                    'TOTAL': ['sum', 'mean']
                }).round(2)
                resumo.columns = ['Quantidade de Itens', 'Valor Total', 'Valor M√©dio']
                
                # Formatar valores monet√°rios no resumo
                resumo['Valor Total'] = resumo['Valor Total'].apply(formatar_moeda_real)
                resumo['Valor M√©dio'] = resumo['Valor M√©dio'].apply(formatar_moeda_real)
                
                st.dataframe(resumo)
            
            # Aba 2: An√°lise Detalhada
            with tab2:
                st.dataframe(df_processado)
            
            # Aba 3: Filtros (mantida como est√°)
            with tab3:
                col1, col2 = st.columns(2)
                with col1:
                   classes_selecionadas = st.multiselect(
                        'Filtrar por classe',
                        ['A', 'B', 'C'],
                        default=['A', 'B', 'C'],
                        help=TOOLTIPS['CLASSIFICA√á√ÉO']
                    )
                
                with col2:
                    valor_min = float(df_processado['TOTAL'].min())
                    valor_max = float(df_processado['TOTAL'].max())
                    valores = st.slider(
                        'Faixa de valores',
                        min_value=valor_min,
                        max_value=valor_max,
                        value=(valor_min, valor_max),
                        format=lambda x: formatar_moeda_real(x)
                    )
                
                busca = st.text_input('Buscar por descri√ß√£o')
                
                # Aplicar filtros
                mask = (
                    (df_processado['CLASSIFICA√á√ÉO'].isin(classes_selecionadas)) &
                    (df_processado['TOTAL'] >= valores[0]) &
                    (df_processado['TOTAL'] <= valores[1])
                )
                
                if busca:
                    mask &= df_processado['DESCRI√á√ÉO'].str.contains(busca, case=False, na=False)
                
                df_filtrado = df_processado[mask]
                st.dataframe(df_filtrado)

            # Aba 4: Relat√≥rio (Nova)
            with tab4:
                st.subheader('Relat√≥rio Completo')
                
                # Sum√°rio Executivo
                st.markdown('### Sum√°rio Executivo')
                total_itens = len(df_processado)
                total_valor = df_processado['TOTAL'].sum()
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric('Total de Itens', total_itens)
                with col2:
                    st.metric('Valor Total', formatar_moeda_real(total_valor))
                with col3:
                    st.metric('M√©dia por Item', 
                             formatar_moeda_real(total_valor/total_itens))
                
                # An√°lise por Classe
                st.markdown('### An√°lise por Classe')
                for classe in ['A', 'B', 'C']:
                    df_classe = df_processado[df_processado['CLASSIFICA√á√ÉO'] == classe]
                    st.markdown(f'**Classe {classe}**')
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric(f'Itens Classe {classe}', 
                                len(df_classe))
                    with col2:
                        valor_classe = df_classe['TOTAL'].sum()
                        st.metric(f'Valor Classe {classe}', 
                                formatar_moeda_real(valor_classe))
                    with col3:
                        percentual = (valor_classe/total_valor * 100)
                        st.metric(f'Percentual Classe {classe}', 
                                f'{percentual:.1f}%')
                
                # Recomenda√ß√µes
                st.markdown('### Recomenda√ß√µes')
                st.markdown("""
                1. **Itens Classe A:**
                   - Implementar controle rigoroso
                   - Revisar pre√ßos frequentemente
                   - Manter relacionamento pr√≥ximo com fornecedores
                
                2. **Itens Classe B:**
                   - Estabelecer controles moderados
                   - Revisar pre√ßos periodicamente
                   - Manter estoque de seguran√ßa adequado
                
                3. **Itens Classe C:**
                   - Simplificar controles
                   - Fazer pedidos em maiores quantidades
                   - Automatizar processos de compra
                """)
                
                # Bot√£o para gerar PDF
                if st.button('üìÑ Gerar Relat√≥rio PDF'):
                    pdf_buffer = gerar_pdf(
                        df_processado, 
                        fig_pareto, 
                        fig_pizza, 
                        resumo
                    )
                    st.download_button(
                        label="üíæ Baixar Relat√≥rio PDF",
                        data=pdf_buffer.getvalue(),
                        file_name=f"relatorio_curva_abc_{datetime.now().strftime('%Y%m%d')}.pdf",
                        mime="application/pdf"
                    )
            
            # Bot√£o de download do Excel com gr√°ficos
            buffer = io.BytesIO()
            with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
                # Dados processados
                df_processado.to_excel(writer, sheet_name='Dados Processados', index=False)
                
                # Adicionar gr√°ficos
                workbook = writer.book
                worksheet = writer.sheets['Dados Processados']
                
                # Salvar gr√°ficos como imagens tempor√°rias
                pareto_img = BytesIO()
                fig_pareto.write_image(pareto_img)
                
                pizza_img = BytesIO()
                fig_pizza.write_image(pizza_img)
                
                # Inserir imagens na planilha
                worksheet.insert_image('A1', 'pareto.png', 
                                     {'image_data': pareto_img})
                worksheet.insert_image('J1', 'pizza.png', 
                                     {'image_data': pizza_img})
            
            st.sidebar.download_button(
                label="üì• Baixar Dados e Gr√°ficos (Excel)",
                data=buffer.getvalue(),
                file_name=f"curva_abc_completa_{datetime.now().strftime('%Y%m%d')}.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
            
        except Exception as e:
            st.error(f'Erro ao processar arquivo: {str(e)}')
            st.info('Verifique se o arquivo est√° no formato correto e cont√©m todos os dados necess√°rios.')

if __name__ == '__main__':
    main()
